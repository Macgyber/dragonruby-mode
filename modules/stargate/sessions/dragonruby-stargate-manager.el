;;; dragonruby-stargate-manager.el --- Stargate Session Management -*- lexical-binding: t -*-

;; Author: Macgyber <esteban3261g@gmail.com>
;; Version: 1.0.0
;; Hardened for v1.0 Blindada: Address Integrity, Fail-Fast Persistence, and FSM.

(require 'cl-lib)
(require 'json)

(defvar json-encoding-object-type)
(defvar dragonruby-stargate--state nil)

(defun dragonruby-stargate--set-state (new-state)
  "Transition Stargate to NEW-STATE with logging."
  (let ((connected (and (boundp 'dragonruby-stargate-bridge--process)
                        (processp dragonruby-stargate-bridge--process)
                        (process-live-p dragonruby-stargate-bridge--process))))
    (when (and (member new-state '(:active :infecting)) (not connected))
      (setq new-state nil)
      (message "ðŸŒŒ STARGATE: [ERROR] Cannot set [%S] state without live process." new-state))
    (unless (eq dragonruby-stargate--state new-state)
      (let ((old dragonruby-stargate--state))
        (setq dragonruby-stargate--state new-state)
        (message "ðŸŒŒ STARGATE: %s âž” %s" (or old "IDLE") (or new-state "IDLE"))))))

(defvar dragonruby-stargate--active-session nil)
(defvar dragonruby-stargate--session-index nil)
(defvar dragonruby-stargate--runtime-infected nil)
(defvar dragonruby-stargate--event-queue nil)
(defvar dragonruby-stargate--persist-timer nil)
(defvar dragonruby-stargate--idle-timer nil)

(defun dragonruby-stargate-session-init (&optional project-root)
  "Initialize a new Stargate session."
  (interactive)
  (let* ((root (or project-root (dragonruby--find-project-root)))
         (stargate-dir (expand-file-name ".stargate/" root))
         (session-id (format-time-string "session-%Y%m%d-%H%M%S"))
         (session-dir (expand-file-name (concat session-id "/") stargate-dir))
         (blobs-dir (expand-file-name "blobs/" session-dir)))
    (unless root (error "Could not find DragonRuby project root"))
    (unless (file-exists-p blobs-dir) (make-directory blobs-dir t))
    (setq dragonruby-stargate--active-session session-dir)
    (let ((moments (make-hash-table :test 'equal :size 5000))
          (branches (make-hash-table :test 'equal))
          (branch-maps (make-hash-table :test 'equal)))
      (puthash "prime" (list (cons "parent" nil) (cons "divergence" 0)) branches)
      (puthash "prime" '() branch-maps)
      (setq dragonruby-stargate--session-index
            (list (cons "schema_version" 1)
                  (cons "protocol_version" "1.0.0")
                  (cons "session_id" session-id)
                  (cons "branches" branches)
                  (cons "moments" moments)
                  (cons "branch-maps" branch-maps))))
    (dragonruby-stargate-session-persist t)
    (when dragonruby-stargate--persist-timer (cancel-timer dragonruby-stargate--persist-timer))
    (setq dragonruby-stargate--persist-timer (run-with-idle-timer 30.0 t #'dragonruby-stargate-session-persist))
    (when dragonruby-stargate--idle-timer (cancel-timer dragonruby-stargate--idle-timer))
    (setq dragonruby-stargate--idle-timer (run-with-idle-timer 0.2 t #'dragonruby-stargate-session--process-queue))
    (message "ðŸŒŒ Stargate: Session %s initialized" session-id)))

(defun dragonruby-stargate-session-load (session-dir)
  "Load an existing Stargate session."
  (interactive (list (read-directory-name "Session: " (expand-file-name ".stargate/" (dragonruby--find-project-root)))))
  (let ((index-file (expand-file-name "session.json" session-dir)))
    (if (not (file-exists-p index-file)) (error "Not found")
      (let* ((json-object-type 'alist) (json-array-type 'list) (json-key-type 'string)
             (json-data (json-read-file index-file))
             (m-alist (cdr (assoc "moments" json-data)))
             (b-alist (cdr (assoc "branches" json-data)))
             (bm-alist (cdr (assoc "branch-maps" json-data)))
             (moments (make-hash-table :test 'equal :size (max 5000 (length m-alist))))
             (branches (make-hash-table :test 'equal))
             (bmaps (make-hash-table :test 'equal)))
        (dolist (m m-alist) (puthash (car m) (cdr m) moments))
        (dolist (b b-alist) (puthash (car b) (cdr b) branches))
        (dolist (bm bm-alist) (puthash (car bm) (cdr bm) bmaps))
        (setq dragonruby-stargate--active-session session-dir)
        (setq dragonruby-stargate--session-index
              (list (cons "schema_version" (or (cdr (assoc "schema_version" json-data)) 1))
                    (cons "protocol_version" (or (cdr (assoc "protocol_version" json-data)) "1.0.0"))
                    (cons "session_id" (or (cdr (assoc "session_id" json-data)) "legacy"))
                    (cons "branches" branches) (cons "moments" moments) (cons "branch-maps" bmaps)))
        (message "ðŸŒŒ Stargate: Session restored (%d moments)" (hash-table-count moments))))))

(defun dragonruby-stargate-session-persist (&optional force)
  "Persist session to disk."
  (when (and dragonruby-stargate--active-session dragonruby-stargate--session-index (or force (not (input-pending-p))))
    (let* ((m-h (cdr (assoc "moments" dragonruby-stargate--session-index)))
           (b-h (cdr (assoc "branches" dragonruby-stargate--session-index)))
           (bm-h (cdr (assoc "branch-maps" dragonruby-stargate--session-index)))
           (m-a nil) (b-a nil) (bm-a nil))
      (maphash (lambda (k v) (push (cons k v) m-a)) m-h)
      (maphash (lambda (k v) (push (cons k v) b-a)) b-h)
      (maphash (lambda (k v) (push (cons k v) bm-a)) bm-h)
      (let ((json-data (list (cons "schema_version" 1) (cons "protocol_version" "1.0.0")
                             (cons "session_id" (cdr (assoc "session_id" dragonruby-stargate--session-index)))
                             (cons "branches" b-a) (cons "moments" m-a) (cons "branch-maps" bm-a))))
        (with-temp-file (expand-file-name "session.json" dragonruby-stargate--active-session)
          (let ((json-encoding-object-type 'alist)) (insert (json-encode json-data))))))))

(defun dragonruby-stargate-session--handle-event (event)
  (let ((type (cdr (assoc "type" event))))
    (if (string= type "divergence")
        (progn (setq dragonruby-stargate--event-queue nil) (dragonruby-stargate-session--record-divergence event))
      (push event dragonruby-stargate--event-queue))))

(defvar dragonruby-stargate-session-updated-hook nil)

(defun dragonruby-stargate-session--process-queue ()
  (unless (and (processp dragonruby-stargate-bridge--process) (process-live-p dragonruby-stargate-bridge--process))
    (when (eq dragonruby-stargate--state :active) (dragonruby-stargate--set-state nil)))
  (when dragonruby-stargate--event-queue
    (let ((batch (reverse dragonruby-stargate--event-queue)))
      (setq dragonruby-stargate--event-queue nil)
      (dolist (e batch)
        (let ((type (cdr (assoc "type" e))))
          (cond ((string= type "moment") (dragonruby-stargate-session-record-moment e))
                ((string= type "branch") (dragonruby-stargate-session-record-branch e))
                ((string= type "infection_ack") (setq dragonruby-stargate--runtime-infected t) (dragonruby-stargate--set-state :active))
                ((string= type "stasis_ack") (message "ðŸ›‘ STARGATE: STASIS."))
                ((string= type "record_ack") (message "ðŸ”´ STARGATE: SYNCING."))))))
    (run-hooks 'dragonruby-stargate-session-updated-hook)))

(defun dragonruby-stargate-session-record-moment (event)
  (let* ((addr (cdr (assoc "address" event))) (hash (cdr (assoc "hash" event))) (seed (cdr (assoc "seed" event)))
         (m-type (cdr (assoc "moment_type" event))) (sid (cdr (assoc "session_id" dragonruby-stargate--session-index)))
         (key (format "%s@%s" sid addr)) (moms (cdr (assoc "moments" dragonruby-stargate--session-index)))
         (bmaps (cdr (assoc "branch-maps" dragonruby-stargate--session-index))) (bid (car (split-string addr "@"))))
    (puthash key (list (cons "hash" hash) (cons "seed" seed) (cons "moment_type" m-type)) moms)
    (let ((ex (gethash bid bmaps))) (unless (member addr ex) (puthash bid (cons addr ex) bmaps)))))

(defun dragonruby-stargate-session-record-branch (event)
  (let ((id (cdr (assoc "id" event))) (p (cdr (assoc "parent" event))) (d (cdr (assoc "divergence" event)))
        (brs (cdr (assoc "branches" dragonruby-stargate--session-index))))
    (puthash id (list (cons "parent" p) (cons "divergence" d)) brs)))

(defun dragonruby-stargate-session-fork (source div new)
  (interactive "sSource: \nnTick: \nsNew: ")
  (let* ((brs (cdr (assoc "branches" dragonruby-stargate--session-index)))
         (bms (cdr (assoc "branch-maps" dragonruby-stargate--session-index)))
         (src (if (string-empty-p source) "prime" source)))
    (if (gethash new brs) (error "Exists")
      (puthash new (list (cons "parent" src) (cons "divergence" div)) brs)
      (puthash new '() bms)
      (when (fboundp 'dragonruby-stargate-timeline-trigger-refresh)
        (dragonruby-stargate-timeline-trigger-refresh))
      (message "ðŸŒŒ Stargate: Branch [%s] born" new))))

(defun dragonruby-stargate-session-get-moment (bid tick)
  (let* ((moms (cdr (assoc "moments" dragonruby-stargate--session-index)))
         (brs (cdr (assoc "branches" dragonruby-stargate--session-index)))
         (sid (cdr (assoc "session_id" dragonruby-stargate--session-index)))
         (key (format "%s@%s@%d" sid bid tick)) (loc (gethash key moms)))
    (if loc loc
      (let* ((data (gethash bid brs)) (p (cdr (assoc "parent" data))) (d (cdr (assoc "divergence" data))))
        (if (and p (<= tick d)) (dragonruby-stargate-session-get-moment p tick) nil)))))

(defun dragonruby-stargate-session--record-divergence (e)
  (message "âš¡ STARGATE: DIVERGENCE at %s" (cdr (assoc "address" e)))
  (dolist (b (buffer-list)) (with-current-buffer b (when (boundp 'dragonruby-stargate--divergence-detected) (setq dragonruby-stargate--divergence-detected t))))
  (dragonruby-stargate-timeline))

(defun dragonruby-stargate-session-stop ()
  (interactive)
  (when dragonruby-stargate--persist-timer (cancel-timer dragonruby-stargate--persist-timer))
  (when dragonruby-stargate--idle-timer (cancel-timer dragonruby-stargate--idle-timer))
  (dragonruby-stargate--set-state nil)
  (setq dragonruby-stargate--runtime-infected nil)
  (when (and dragonruby-stargate--active-session dragonruby-stargate--session-index)
    (dragonruby-stargate-session-persist t)
    (setq dragonruby-stargate--active-session nil dragonruby-stargate--session-index nil)))

(add-hook 'dragonruby-stargate-bridge-event-hook #'dragonruby-stargate-session--handle-event)
(provide 'dragonruby-stargate-manager)
;;; dragonruby-stargate-manager.el ends here
